 // Headers for trusted part (autogenerated by edger8r)
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>

#include "bypass_to_sgx.h"
#include "sgx_thread.h"
#include "sgx_tae_service.h"

#define LOOPS_PER_THREAD 100




void sgx_gettime()
{
    sgx_time_source_nonce_t nonce = {0};

        sgx_time_t current_timestamp,edn_tiem;
       int ret = sgx_get_trusted_time(&current_timestamp, &nonce);
       printf("currenttime %ld\n",current_timestamp);
   for(int i=0;i<1000;i++)
   {printf("ok");}
          ret = sgx_get_trusted_time(&edn_tiem, &nonce);
       printf("\nend %ld\n",edn_tiem);


printf("end-satrt%ld\n",edn_tiem-current_timestamp);
}


time_t time(time_t * tim)
{
	time_t retval;
	sgx_status_t status = ocall_time(&retval, tim);
	//CHECK_STATUS(status);
	return retval;
}

int gettimeofday(void * tv, void * tz)
{
	int retval;
	sgx_status_t status;
	if (tz!=NULL)
		status = ocall_gettimeofday(&retval, tv, sizeof(struct timeval), tz, sizeof(struct timezone));
	else	{
		status = ocall_gettimeofday2(&retval, tv, sizeof(struct timeval));
	}
	//CHECK_STATUS(status);
	return retval;
}

static double get_now(void) {
	struct timeval tv;
	int rc;

	rc = gettimeofday(&tv, NULL);
	if (rc != 0) {
		/* Should never happen, so return whatever. */
		return 0.0;
	}
	return ((double) tv.tv_sec) * 1000.0 + ((double) tv.tv_usec) / 1000.0;
}

void test_ecall(void)
{
    printf("hiiii");
}



// Learns and predicts hand written digits with 98% accuracy.
void test_main(void)
{
 // printf("get now %ld\n", get_now());
      struct timeval start, end;

  gettimeofday(&start, NULL);

  for (int i = 0; i < 1000; i++)
    {
                printf("ok");

    }
                printf("ok\n");

  gettimeofday(&end, NULL);
    printf("%ld\n",start.tv_usec);
  printf("%ld\n",end.tv_usec);



    return 0;
}


int fprintf(int FILESTREAM, const char* fmt, ...)
{
    char buf[WRAPBUFSIZ] = {'\0'};
    int result = 0;
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(buf, WRAPBUFSIZ, fmt, ap);
    va_end(ap);
    sgx_status_t status = ocall_fprint_string(&result, FILESTREAM, buf);
   // CHECK_STATUS(status);
    return result;
}

void ecall_main(int argc, char **argv)
{


  //  caches_main(argc,argv);

}


void exit(int status)
{
  printf("exit\n");
  abort();
}
